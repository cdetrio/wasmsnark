const vk = {"a": [{x: "8027588103748094995900778053664283761977569897443870364126833636639610007748", y: "3402975421449873418228553715947690608987867605775775703655722103762561826516", z: "1"}, {x: "6584841608425008688423627424270213274023468161739711515013028065945960496997", y: "6647457698525871768883341861153287701653562937795398727832610800836105886413", z: "1"}], "b": {x: "fe242a0ba3f7711a856e6f71140f890a3fe2f3fd0c22c5ed5271397d51218b0", y: "0x15f38ab13609f452647644823721f6868eac9f978b4e7701c2478b3e1c72fb60", z: "1"}, "c": [{x: "0x2f5e46111126f2c82fbb3948856bddf2f1c1135094b57787a0c2ae470c7fbe47", y: "0xb410504baaf9838cb5e9a9abc5bd0dc90738f65ab933229b86279e2952b3898", z: "1"}, {x: "0x3060faf2c04a26754a7aebd84c7813719d6198b246f55bd660728d1e60a28f84", y: "0x2d2d10089b2dbcb0899dd12d5f2597e713121f9a77906037e93a48656f39dde", z: "1"}], "g": [{x: "0x2d6f4aee0f29312e52a4d7d157341b43b714a6cc966259c63fc034a55c36b32c", y: "0x1a3364971dc1d74308d83eb009b0e135da216aa7539e6a2616bb8f9a4f5c4f57", z: "1"}, {x: "0x8a50f089e3132331ad45bd5b9dab7ee1c2242996a2e4f41d73c15640beee106", y: "0x2d6c10635fa6f29d67c70fc37ff72737fc60eb310f0d78cfcb64dce8a5835ef2", z: "1"}], "gb1": {x: "238be2b6be47f40f4dc44b0db93f444c93c52218bc64aefcee8121d39c10ced7", y: "0x10ffb1715fce6e06beb0297f35f7eb5f38c1d93ca2afa21592cadcad0be1b38f", z: "1"}, "gb2": [{x: "0x1148787f16c53a66d5a6908cc2a73e309912f4e7dbc5fe09879cdea7234807e6", y: "0x1338030c160b96f3d21aad1196004e4cbf23f227ea94afe582dbd91d1bfc8a13", z: "1"}, {x: "0x2516745127db9af58fbe704512e8ee71b83202d3364063688ceb69a3ed32120d", y: "0x124c2e3982ec30d2d42c38731b247bd6e193ccfe1e88c00cce5f4b075805cce7", z: "1"}], "z": [{x: "0x2eb94ed61a776b8c76b8c09bdd00796f1a06b960dba9172fbef032874984cbc5", y: "0x8154503f76d2ba16a00d9367673613066a306968b800a32bbe5f5db3b60c3c8", z: "1"}, {x: "0x7ac9fb9f7d9db9b0edd3cd662191d7692cc1578503e5aa0bc763dfea09ec0d0", y: "0x1bc83cd72f2c4e34b5d438ca80dbd51dc842ed31de6bef9b48817c8550e6bba", z: "1"}], "IC": [{x: "23c774c717e5b7b06daf61d6e1ff81ab7766bf7c033162038c76585f2d184839", y: "0x1fb1a7a7e610d7b30e196afb9bdab49806944a77433510c1f21b5ec16a7e26a2", z: "1"}, {x: "8fd217426deca174c978adf9b30a9e9083bd1de5716913e8c811e195c65a291", y: "0x1c8bba17884943c914f0e2598a0f3ee3aebbb8775817ea6d56436699b8316719", z: "1"}, {x: "619a8b3e5efdca55ca1ae8e9777b579520392af6d663f0a515cbb1de541ebb7", y: "0x1a2c8fc7a111d9ca7d127b8cc07aa07b1c674592093f924feed2c1a69b449a3d", z: "1"}, {x: "1f5d4aec94e62c96c6df0f4a0985770ee51bc5c4f426c0ab4b3f756f9d2ca285", y: "0xe3bb0223471da6cbf932737a49c79a57ed0cec4a11f54ae912c6870712646e3", z: "1"}, {x: "215932e36f1c5898394450390ea392351db28a754cfc2082c7a4ae9f2a34f8e6", y: "0x21dfdd2adf402e1463f6838b9c5347db9ed22d9d2652dfaa6bd5a3ad049b7678", z: "1"}, {x: "26598d6500f886c07bb99f06881d2809d914af205fb34fce69f5e63c9980dc5", y: "0x2d87610d87fabbb72743551a11b36ff2eb55847b47e9a7394f9a6f1ce546fd6d", z: "1"}, {x: "56d28781810e1cacd3ed3dd4a6e956a7bb204f53751100c9dd5c963699cfc04", y: "0x18e69a6062f2fb05e0007268b9be1cbf7aeb5d15d802dd03a0c07d9af9b5df13", z: "1"}]}

const proof = {"a": ["8101821407142431521291764317689918300673680361075680840890613284590881361090", "11188528619562267138106591416845761751256898941415261417424373582469865096768", "1"], "a_p": ["19606299122199532454450118976810935520081075164153121050769727751298007159034", "15857089354639735753471417565471769743721157556354035445450150505726079565978", "1"], "b": [["1193899284414344884939581528507696119069326151812354449067751161943021270807", "10596712396198770470036141769130790532480968641024664152359006376635697799116", "1"], ["17907817161027600387956385399852324604915775864432856183848213408830694799127", "17672380469009572773919645209712306332616649472803550332313479336620129122245", "1"]], "b_p": ["14467365953033168477313502505208986438316735567670072407289037786275813800439", "6138396842555231515277351211225655169530837893982133813295501059207970878866", "1"], "c": ["18244512191373922178068269556360801787659247215895130362997383922678954242323", "13032816726359756142055485830722858331883858702238820205265977535858005301949", "1"], "c_p": ["15695594638794200005262073157014628920668543364289904898759303711316110500147", "10154130232415526629036276170723145685516407994167474739439413246452103132897", "1"], "h": ["12461863069689606723298763725553616722952836258699737918710411673526871008461", "15191551311833286030750129143933770258349566421941945320133351922427908714766", "1"], "k": ["19899164578423057654302432609455168520037892378828718711027472793314590019403", "19972990059386613567146759459600521004766368063604638323204768588760336006326", "1"], "input": ["10023990726703916044346885959154654865524949824588662605098551026192542737871", "2", "12179642599921583044492796414072058817245043511036050444086056572891590802390", "4", "1922921700301673738659831850011930844888547773281558769808146861610944864629", "9299250400689089910240682594415691479114552969120829821387576864786494048524", "1"]}

const buildBn128 = require("./src/bn128.js");
const SIZE_F = 32

function buildProofAndVK(bn128) {
    let result = {
      proof: {},
      vk: {}
    };

    /*
    let a_0 = bn128.alloc(96);
    bn128.setG1Affine(a_0, [vk.a[0].x, vk.a[0].y, vk.a[0].z]);
    let a_1 = bn128.alloc(96);
    bn128.setG1Affine(a_1, [vk.a[1].x, vk.a[1].y, vk.a[1].z]);
    */

    let vk_a_0 = [vk.a[0].x, vk.a[0].y, vk.a[0].z]
    let vk_a_1 = [vk.a[1].x, vk.a[1].y, vk.a[1].z]

    let vk_a = bn128.alloc(SIZE_F * 6)
    bn128.setG2Affine(vk_a, [vk_a_0, vk_a_1]);

    //result.proof.a_p = {}
    let a_p = bn128.alloc(SIZE_F * 3)
    //bn128.g1_affine([proof.a_p[0], proof.a_p[1]]);
    bn128.setG1Affine(a_p, proof.a_p);
    //bn128.setG1Affine(a, proof.a);

    //result.proof.a = bn128.g1_affine([proof.a[0], proof.a[1]]);
    let a = bn128.alloc(SIZE_F * 3);
    bn128.setG1Affine(a, proof.a);
    //result.vk.a = bn128.instance.exports.g2_affine([vk.a[0], vk.a[1], vk.a[2]]);

    result = {
        "vk": {
            "a": vk_a
        },
        "proof": {
            "a_p": a_p,
            "a": a
        }
    }

    return result;
}

function buf2hex(buffer) { // buffer is an ArrayBuffer
  return Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join('');
}


let zk = {};

buildBn128().then( (bn128) => {
    zk.bn128 = bn128;

	zk.verify = function(vk, input, proof) {
        loaded_proof = buildProofAndVK(bn128)
        let tmp = bn128.alloc(SIZE_F*3);
        
        /*
        bn128.instance.exports.putBin(vk_x, bn128.instance.exports.g1_fromAffine(["0", "0", "1"]));
        // bn128.instance.exports.putBin(tmp, bn128.instance.exports.g1_fromAffine(["0", "0", "1"]));

		for (uint i = 0; i < proof.input.length(); i++) {
            // vk_x <- vk.IC[i+1] * input[i] + vk_x
            // bn128.instance.exports.putBin(tmp, vk.IC[i+1]);
            bn128.instance.exports.g1_timesScalar(vk.IC[i+1], input[i], 32, tmp);
            bn128.instance.exports.g1_add(vk_x, tmp, vk_x);
        }

        bn128.instance.exports.g1_add(vk_x, vk.IC[0], vk_x);

        */
        bn128.instance.exports.g1m_neg(loaded_proof.proof.a_p, tmp);


        console.log(buf2hex(bn128.getBin(loaded_proof.vk.a, SIZE_F * 6)));
        console.log(buf2hex(bn128.getBin(loaded_proof.proof.a, SIZE_F * 3)));
        console.log(buf2hex(bn128.getBin(tmp, SIZE_F * 3)));
        console.log(buf2hex(bn128.getBin(bn128.pG2gen, SIZE_F * 6)));
        debugger
        if (!bn128.instance.exports.bn128_pairingEq2(loaded_proof.proof.a, loaded_proof.vk.a, tmp, bn128.pG2gen)) {
            console.log("verification failed...");
        }
	}

    zk.verify(vk, proof.input, proof);
});

/*

   function verify(uint[] input, Proof proof) internal returns (uint) {
        VerifyingKey memory vk = verifyKey;
        require(input.length + 1 == vk.IC.length);

        for (uint i = 0; i < input.length; i++)
            vk_x = Pairing.add(vk_x, Pairing.mul(vk.IC[i + 1], input[i]));
        vk_x = Pairing.add(vk_x, vk.IC[0]);

        if (!Pairing.pairingProd2(proof.A, vk.A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;
        if (!Pairing.pairingProd2(vk.B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;
        if (!Pairing.pairingProd2(proof.C, vk.C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;
        if (!Pairing.pairingProd3(
            proof.K, vk.gamma,
            Pairing.negate(Pairing.add(vk_x, Pairing.add(proof.A, proof.C))), vk.gammaBeta2,
            Pairing.negate(vk.gammaBeta1), proof.B
        )) return 4;
        if (!Pairing.pairingProd3(
                Pairing.add(vk_x, proof.A), proof.B,
                Pairing.negate(proof.H), vk.Z,
                Pairing.negate(proof.C), Pairing.P2()
        )) return 5;
        return 0;
    }

        proof.A = Pairing.G1Point(a[0], a[1]);
        proof.A_p = Pairing.G1Point(a_p[0], a_p[1]);
        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
        proof.B_p = Pairing.G1Point(b_p[0], b_p[1]);
        proof.C = Pairing.G1Point(c[0], c[1]);
        proof.C_p = Pairing.G1Point(c_p[0], c_p[1]);
        proof.H = Pairing.G1Point(h[0], h[1]);
        proof.K = Pairing.G1Point(k[0], k[1]);
        uint[] memory inputValues = new uint[](input.length);
        for(uint i = 0; i < input.length; i++){
            inputValues[i] = input[i];
        }

        if (verify(inputValues, proof) == 0) {
            Verified("Transaction successfully verified.");
            return true;
        } else {
            return false;
        }
        */
